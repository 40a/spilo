#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import ConfigParser
import logging
import threading
import json
import psycopg2
import os
import sys
import socket
import signal
import time
import yaml
import subprocess

from psycopg2.extras import RealDictCursor

def signal_handler(signal, frame):
    global psql
    global tunnel

    close_tunnel()

    for p in [psql, tunnel]:
        if p is not None:
            if p.returncode is None:
                logging.warning("Terminating process with pid={}".format(p.pid))
                p.kill()

    os.system('stty sane')
    sys.exit(1)

def get_args():
    argp = \
        argparse.ArgumentParser(description='Commandline wrapper to connect to spilo. Any commandline parameters that are not recognized are passed on to psql'
                                )

    argp.add_argument('-v', '--verbose', dest='loglevel', help='set loglevel to DEBUG', action='store_const',
                      const=logging.DEBUG)
    argp.add_argument('--log_level', '--loglevel', dest='loglevel', help='Set the log level.')
    argp.add_argument('--odd-host', dest='odd_host', help='Odd SSH bastion hostname')
    argp.add_argument('--odd-user', dest='user_name', help='Username to use for OAuth2 authentication')
    argp.add_argument('--config-file', dest='odd_config_file', help='Alternative odd config file')
    argp.add_argument('--watch', dest='watch', help='Repeat the action every WATCH seconds')

    group = argp.add_mutually_exclusive_group()

    group.add_argument('--connect', dest='connect', help='Connect to specified Spilo cluster using psql',
                       action='store_true')
    group.add_argument('--hc','--healthcheck', dest='healthcheck', help='Display health status of Spilo', action='store_true')
    group.add_argument('--tunnel', dest='tunnel', help='Create a tunnel only and output connection information',
                       action='store_true')

    argp.add_argument('-p', '--port', dest='pg_port', help='The PostgreSQL listening port')

    argp.set_defaults(loglevel='WARNING')
    argp.set_defaults(healthcheck=False)
    argp.set_defaults(tunnel=False)
    argp.set_defaults(connect=False)
    argp.set_defaults(watch=None)

    argp.set_defaults(pg_port=5432)

    argp.add_argument('cluster', help='The Spilo cluster to connect to, can also be a pg_service name')

    args, remainder = argp.parse_known_args()
    args = vars(args)

    # # If no action is specified, we assume connect
    if not args['healthcheck'] and not args['tunnel']:
        args['connect'] = True

    return args, remainder


def pretty(something):
    return json.dumps(something, sort_keys=True, indent=4)

def build_psql_cmd(config):
    global tunnel_port

    psql_cmd = [
        'psql',
        '--host',
        'localhost',
        '--port',
        str(tunnel_port)
    ]

    if config.get('pg_service_section') is not None:
        psql_cmd += ['service={}'.format(config['pg_service_section'])]

    psql_cmd.extend(config['unparsed_args'])

    logging.debug('psql command: {}'.format(psql_cmd))

    return psql_cmd

def build_ssh_cmd(config):
    ssh_cmd = ['ssh']
    if config.get('user_name') is not None:
        ssh_cmd.append('{}@{}'.format(config['user_name'], config['odd_host']))
    else:
        ssh_cmd.append(config['odd_host'])

    return ssh_cmd

def open_tunnel(config, port=None):
    global tunnel
    global tunnel_port

    ## We open a socket and let the system choose a port which is free for us
    sock = socket.socket()
    sock.bind(('', 0))
    tunnel_port = int(sock.getsockname()[1])
    logging.debug('Found free port number: {}'.format(tunnel_port))

    ssh_cmd = build_ssh_cmd(config)

    DEVNULL = open(os.devnull, 'wb')

    logging.debug('Testing if ssh access even works')
    test = subprocess.check_output(ssh_cmd + ['printf t3st'], shell=False, stderr=DEVNULL)
    if test != 't3st':
        logging.error('Could not setup a working tunnel. You may need to request access using piu')
        raise Exception(test)

    ## We will close the opened socket as late as possible, to prevent other processes from occupying this port
    ssh_cmd.append('-L')
    port = port or config['pg_port'] or config['pg_service'].get('port')
    sock.close()
    ssh_cmd.append('{}:{}:{}'.format(tunnel_port, config['pg_service'].get('host') or config['cluster'], port))

    ssh_cmd.append('-N')

    logging.info('Setting up tunnel command: {}'.format(ssh_cmd))

    tunnel = subprocess.Popen(ssh_cmd, shell=False, stderr=DEVNULL, stdin=DEVNULL)
    tunnel.poll()
    if tunnel.returncode is not None:
        raise Exception('Tunnel not running anymore, exitcode tunnel: {}'.format(tunnel.returncode))
        

    ## Wait for the tunnel to be available
    sock   = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn_test = ('127.0.0.1', tunnel_port)
    result = sock.connect_ex(conn_test)

    timeout = 5
    epoch_time = time.time()
    threshold_time = time.time() + timeout

    ## Loop until connection is established
    while result <> 0:
        time.sleep(0.1)
        result = sock.connect_ex(conn_test)
        if time.time() > threshold_time:
            raise Exception("Tunnel was not established within timeout of {} seconds".format(timeout))
            break

    sock.close()

    logging.debug("Established connectivity on tunnel after {} seconds".format(time.time() - epoch_time))

def close_tunnel():
    global tunnel

    logging.info('Terminating tunnel')

    tunnel.send_signal(signal.SIGINT)
    tunnel.wait()

def load_pg_service(config):
    """ Load the services from the pg_service file """

    ## First check for explicitly specified service files
    pg_service_file = config.get('pg_service_file') or os.environ.get('PGSERVICEFILE')

    ## Check the PGSYSCONFDIR
    if pg_service_file is None:
        pg_service_dir = os.environ.get('PGSYSCONFDIR')
        if pg_service_dir is not None:
            pg_service_file = os.path.join(pg_service_dir, 'pg_service.conf')

    if pg_service_file is None:
        pg_service_file = os.path.join('~', '.pg_service.conf')

    pg_service_file = os.path.expanduser(pg_service_file)
    logging.debug('Using pg_service_file: {}'.format(pg_service_file))
    
    if not os.path.isfile(pg_service_file):
        logging.info("Connection Service File does not exist (checked {})".format(pg_service_file))
        return dict()

    logging.debug('Reading configuration from pg_service_file {}'.format(pg_service_file))
    cp = ConfigParser.ConfigParser()
    cp.read(pg_service_file)

    pg_service = dict()

    for section in [config['cluster'], 'spilo', 'default']:
        if cp.has_section(section):
            logging.debug('Using section {} in pg_service_file'.format(section))
            pg_service = dict(cp.items(section))
            config['pg_service_section'] = section
            break

    return pg_service
        
def load_odd_config(config):
    """ Load the odd config from a default file, or a specified file and override options with provided values"""

    if config.get('odd_config_file') is not None:
        filename = config.get('odd_config_file')
    elif sys.platform == 'darwin':
        filename = '~/Library/Application Support/piu/piu.yaml'
    else:
        filename = '~/.config/piu/piu.yaml'

    filename = os.path.expanduser(filename)
    logging.debug("Using {} as the piu config file".format(filename))

    if os.path.isfile(filename):
        with open(filename, 'r') as cf:
            odd_config = yaml.load(cf)
        logging.debug('Loaded odd config from file {}: {}'.format(filename, pretty(odd_config)))
    else:
        odd_config = dict()

    ## Merge dicts, config has precedence as it is explicitly specified by the user
    for key in odd_config:
        config[key] = config.get(key) or odd_config[key]

    return config

def tunnel(config):
    open_tunnel(config)
    print 'You can now open a connection to the {} cluster using the following connection information:'.format(config['cluster'
            ])
    print ''
    print ' '.join(build_psql_cmd(config))
    print ''
    print 'press CTRL+C to terminate the tunnel'
    while True:
        try:
            time.sleep(30)
            tunnel.poll()
            if tunnel.returncode is not None:
                raise Exception('Tunnel terminated with exitcode {}'.format(tunnel.returncode))
        except KeyboardInterrupt:
            break
    close_tunnel()


def execute_psql(config):
    global tunnel_port
    global psql

    psql_cmd = build_psql_cmd(config)

    logging.debug('psql command: {}'.format(psql_cmd))
 
    psql = subprocess.Popen(psql_cmd)
    while psql.returncode is None:
        try:
            psql.wait()
        except KeyboardInterrupt:
            logging.debug("Caught KeyboardInterrupt from user")
            psql.send_signal(signal.SIGINT)

    logging.info("psql terminated with exitcode {}".format(psql.returncode))

def get_connection(config):
    global tunnel_port

    conn_parameters = {'host':'localhost', 'port':tunnel_port}

    if config.get('pg_service_section') is not None:
        conn_parameters['service'] = config['pg_service_section']

    conn = psycopg2.connect(**conn_parameters)

    return conn

def healthcheck(config):
    open_tunnel(config)
    naptime = float(config['watch'])


    conn = get_connection(config)
    conn.set_session(readonly=True, autocommit=True)
    cursor=conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute('select rolsuper from pg_roles where rolname=current_user')
    row = cursor.fetchone()

    if row['rolsuper']:
        healthcheck_sql = """
                    WITH repslots AS (
                        SELECT pid,
                               usename,
                               client_addr,
                               backend_start
                          FROM pg_stat_replication
                    )"""
    else:
        healthcheck_sql = """
                    WITH repslots AS (
                        SELECT pid,
                               usename
                          FROM pg_stat_replication
                    )"""
    healthcheck_sql += """        
                    SELECT to_char(pg_postmaster_start_time(), 'YYYY-MM-DD HH24:MI:SS.MS TZ') AS postmaster_start_time,
                           (clock_timestamp() - pg_postmaster_start_time())::text AS uptime,
                           pg_current_xlog_location(),
                           (SELECT ('x'||substr(pg_xlogfile_name('0/00000000'), 1, 8))::bit(32)::int) AS current_timeline,
                           (SELECT json_agg(repslots) FROM repslots) AS slaves,
                           (select setting::int - count(*) from pg_replication_slots join pg_settings on (name='max_replication_slots') group by setting) AS remaining_replication_slots
                                  """
    conn = None
    while True:
        try:
            if conn is None:
                conn = get_connection(config)
                conn.set_session(readonly=True, autocommit=True)
                cursor=conn.cursor(cursor_factory=RealDictCursor)

            cursor.execute(healthcheck_sql)
            row = cursor.fetchone()
            healthcheck = dict(row)
            print pretty(healthcheck)
            if naptime is None:
                break
        except (psycopg2.OperationalError, psycopg2.DatabaseError) as e:
            logging.warning('Connection error occured, will keep retrying, {}'.format(e.pgerror or ''))
            logging.debug('', exc_info=True)
            conn = None
            time.sleep(5)

        time.sleep(naptime)

    cursor.close()
    conn.close()

    close_tunnel()
    return

def connect(config):
    global tunnel_port

    open_tunnel(config)
    execute_psql(config)
    close_tunnel()

    return

def main():
    global tunnel_port
    global psql

    psql = None

    config, config['unparsed_args'] = get_args()
    logging.basicConfig(format='%(asctime)s - %(threadName)s - %(levelname)s - %(message)s', level=config['loglevel'])
    config = load_odd_config(config)

    config['pg_service'] = load_pg_service(config)

    logging.debug('Configuration: {}'.format(pretty(config)))
    logging.debug('Remaining arguments: {}'.format(config['unparsed_args']))

    #signal.signal(signal.SIGINT, signal_handler)
#    signal.signal(signal.SIGTERM, signal_handler)

    if config['connect']:
        connect(config)
        return

    if config['healthcheck']:
        healthcheck(config)
        return

    if config['tunnel']:
        tunnel(config)
        return

if __name__ == '__main__':
    main()
